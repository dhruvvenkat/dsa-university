# Greedy Algorithms - Introduction

## Overview

Greedy algorithms make locally optimal choices at each step, hoping to find a global optimum. They're simple and efficient but don't always produce optimal solutions.

## Key Concepts

1. **Greedy Choice Property**: Locally optimal choice leads to global optimum
2. **Optimal Substructure**: Problem can be solved by combining optimal solutions to subproblems
3. **No Backtracking**: Once a choice is made, it's never reconsidered

## When to Use Greedy

- Optimization problems
- Problems with greedy choice property
- When local optimum leads to global optimum
- Problems where DP would be overkill

## Common Patterns

1. **Activity Selection**: Choose maximum non-overlapping activities
2. **Interval Scheduling**: Schedule maximum activities
3. **Fractional Knapsack**: Take items partially
4. **Huffman Coding**: Optimal prefix codes
5. **Minimum Spanning Tree**: Kruskal's, Prim's algorithms

## Learning Path (Future)

After completing the 30-day course:
- Day 1: Activity Selection, Interval Scheduling
- Day 2: Fractional Knapsack, Job Scheduling
- Day 3: Huffman Coding (conceptual)
- Day 4: Minimum Spanning Tree concepts
- Day 5: Greedy vs DP comparison

## Practice Problems (No Solutions - Implement Yourself)

1. Activity Selection
2. Interval Scheduling
3. Fractional Knapsack
4. Meeting Rooms
5. Non-overlapping Intervals
6. Jump Game
7. Gas Station
8. Assign Cookies
9. Queue Reconstruction by Height
10. Minimum Number of Arrows to Burst Balloons

---

**Note**: This topic is marked for future learning after completing the core 30-day curriculum. Master the fundamentals first!

